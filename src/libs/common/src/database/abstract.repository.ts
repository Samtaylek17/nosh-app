import { HttpStatus, Logger, NotFoundException } from '@nestjs/common';
import {
  FilterQuery,
  Model,
  Types,
  UpdateQuery,
  SaveOptions,
  Connection,
  PopulateOptions,
} from 'mongoose';
import { AbstractDocument } from './abstract.schema';
import { MongoException } from '@app/common';

export interface PaginationOptions<TDocument> {
  page: number; // Current page number
  limit: number; // Number of documents per page
  sort?: {
    field: string; // Field to sort by
    order: 'asc' | 'desc'; // Sorting order: 'asc' for ascending, 'desc' for descending
  };
  filter?: Partial<TDocument>; // Filtering criteria
  search?: {
    searchFields: string[];
    keyword: string;
  }; // Search keyword
}

export abstract class AbstractRepository<TDocument extends AbstractDocument> {
  protected abstract readonly logger: Logger;

  constructor(
    protected readonly model: Model<TDocument>,
    private readonly connection: Connection,
  ) {}

  /**
   * This function creates a new document with a generated ObjectId and saves it to the database.
   * @param document - The `document` parameter is an object of type `TDocument` with the `_id`
   * property omitted. `TDocument` is a generic type that represents the shape of a document in a
   * MongoDB collection. The `_id` property is a unique identifier for the document, which is
   * automatically generated by
   * @param {SaveOptions} [options] - `options` is an optional parameter of type `SaveOptions` that can
   * be passed to the `save()` method of the created document. `SaveOptions` is an interface that
   * defines various options that can be used to configure the behavior of the `save()` method, such as
   * `validateBeforeSave
   * @returns The `create` function returns a Promise that resolves to a new document of type
   * `TDocument`. The document is created by instantiating a new instance of the `model` with the
   * provided `document` object and a new `_id` generated using `Types.ObjectId()`. The `save` method
   * is then called on the new document with the provided `options`, and the resulting saved document
   * is returned
   */
  async create(
    document: Omit<TDocument, '_id'>,
    options?: SaveOptions,
  ): Promise<TDocument> {
    try {
      const createdDocument = new this.model({
        ...document,
        _id: new Types.ObjectId(),
      });
      return (
        await createdDocument.save(options)
      ).toJSON() as unknown as TDocument;
    } catch (err) {
      throw new MongoException(err.message, HttpStatus.BAD_REQUEST);
    }
  }

  /**
   * This function finds and returns a single document based on a filter query, throwing a
   * NotFoundException if no document is found.
   * @param filterQuery - FilterQuery is a type that represents a query used to filter documents in a
   * MongoDB collection. It is typically an object that specifies the criteria for the query, such as
   * matching a specific field value or range of values. In this case, the filterQuery parameter is
   * used to find a single document in the
   * @returns The `findOne` method returns a Promise that resolves to a single document of type
   * `TDocument` that matches the provided `filterQuery`. If no document is found, it throws a
   * `NotFoundException` with a message "Document not found."
   */
  async findOne(
    filterQuery: FilterQuery<TDocument>,
    populateOptions?: PopulateOptions,
    selectOptions?:
      | string
      | string[]
      | Record<string, number | boolean | object>,
  ): Promise<TDocument> {
    const query = this.model.findOne(filterQuery, {});

    if (populateOptions) {
      query.populate(populateOptions);
    }

    if (selectOptions) {
      query.select(selectOptions);
    }

    if (!query) {
      this.logger.warn('Document not found with filterQuery', filterQuery);
      throw new NotFoundException('Document not found.');
    }

    return query.exec();
  }

  /**
   * This function finds and updates a document in a MongoDB collection based on a filter query and
   * returns the updated document.
   * @param filterQuery - A query object that specifies the criteria for selecting documents to update.
   * It can contain one or more key-value pairs, where each key represents a field in the document and
   * each value represents the desired value for that field.
   * @param update - The `update` parameter is an object that contains the fields and values to be
   * updated in the document. It can include update operators such as ``, ``, ``, etc.
   * @returns This function returns a Promise that resolves to a single document of type TDocument
   * after updating it based on the provided filterQuery and update parameters. If no document is found
   * with the given filterQuery, a NotFoundException is thrown.
   */
  async findOneAndUpdate(
    filterQuery: FilterQuery<TDocument>,
    update: UpdateQuery<TDocument>,
    populateOptions?: PopulateOptions,
    selectOptions?:
      | string
      | string[]
      | Record<string, number | boolean | object>,
  ): Promise<TDocument | null> {
    try {
      const query = this.model.findOneAndUpdate(filterQuery, update, {
        new: true,
      });

      if (selectOptions) {
        query.select(selectOptions);
      }

      if (populateOptions) {
        query.populate(populateOptions);
      }

      if (!query) {
        this.logger.warn(`Document not found with filterQuery:`, filterQuery);
        throw new NotFoundException('Document not found.');
      }

      return query.exec();
    } catch (err) {
      throw new MongoException(
        err.message,
        err.status || HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * This is an async function that updates or inserts a document in a MongoDB collection based on a
   * filter query and returns the updated document.
   * @param filterQuery - `filterQuery` is a query object that specifies the criteria for selecting
   * documents to update in the MongoDB collection. It is of type `FilterQuery<TDocument>`, where
   * `TDocument` is the type of the document being updated. The query object can contain one or more
   * key-value pairs that represent
   * @param document - `document` is a partial object of type `TDocument` which contains the data to be
   * upserted. It is a subset of the full document and may contain only the fields that need to be
   * updated or inserted. The `upsert` option in the `findOneAndUpdate` method will insert
   * @returns The `upsert` function is returning a Promise that resolves to the updated document after
   * performing an upsert operation on the MongoDB collection using the `findOneAndUpdate` method. The
   * `filterQuery` parameter is used to find the document to update or insert, and the `document`
   * parameter contains the new data to be inserted or updated. The `lean`, `upsert`, and `new` options
   */
  async upsert(
    filterQuery: FilterQuery<TDocument>,
    document: Partial<TDocument>,
  ) {
    try {
      return this.model.findOneAndUpdate(filterQuery, document, {
        lean: true,
        upsert: true,
        new: true,
      });
    } catch (err) {
      throw new MongoException(err.message, HttpStatus.BAD_REQUEST);
    }
  }

  /**
   * This is an asynchronous function that finds documents based on filter, pagination, sorting,
   * filtering, and search options.
   * @param filterQuery - A query object used to filter the documents to be returned.
   * @param paginationOptions - PaginationOptions is an object that contains options for pagination,
   * sorting, filtering, and searching. It has the following properties:
   * @returns The `find` method is returning a Promise that resolves to an array of documents that
   * match the provided `filterQuery`, `paginationOptions`, and any additional query options that were
   * applied. The documents are returned as plain JavaScript objects because the `lean` option is set
   * to `true`.
   */
  async find(
    filterQuery: FilterQuery<TDocument>,
    paginationOptions?: PaginationOptions<TDocument>,
    populateOptions?: PopulateOptions | PopulateOptions[],
  ) {
    const { page, limit, sort, filter, search } = paginationOptions;

    const query = this.model.find(filterQuery, {}, { lean: true });

    // Populate Options
    if (populateOptions) {
      query.populate(populateOptions);
    }

    // Pagination
    const skip = (page - 1) * limit;
    query.skip(skip).limit(limit);

    // Sorting
    if (sort) {
      const { field, order } = sort;
      query.sort({ [field]: order });
    }

    // Filtering
    if (filter) {
      query.where(filter);
    }

    // Search
    if (search) {
      const searchFields = search.searchFields; // Replace with your actual searchable fields
      const regex = new RegExp(search.keyword, 'i');
      query.where({ $or: searchFields.map((field) => ({ [field]: regex })) });
    }

    return query.exec();
  }

  /**
   * The count function returns the number of documents that match the given filter query.
   * @param filterQuery - The `filterQuery` parameter is a query object that specifies the conditions
   * that documents must meet in order to be counted. It is used to filter the documents in the
   * collection before counting them.
   * @returns The count of documents that match the filter query.
   */
  async count(filterQuery: FilterQuery<TDocument>): Promise<number> {
    return this.model.countDocuments(filterQuery);
  }

  /**
   * This function starts a transaction using a session in a TypeScript code.
   * @returns The `startTransaction()` method is returning a MongoDB session object that has been
   * started and is ready to be used for a transaction.
   */
  async startTransaction() {
    const session = await this.connection.startSession();
    session.startTransaction();
    return session;
  }
}
